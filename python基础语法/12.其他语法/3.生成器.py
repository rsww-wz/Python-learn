"""
生成器简介
    生成器使用的不广泛的特性之一，是在其他主流语言里面没有生成器的概念

生成器理解
    如果有100w个数字有一定规律的列表元素，存储会浪费大量空间，访问也会增加计算
    并且如果只需要访问列表中的几个元素，后面元素的占用空间就会被浪费
    又或者要存储一个有无穷项的数列，长度不确定，无法完成初始化

    但是如果列表中的元素可以按照某种算法推算出来，那么通过存储少量的值
    也可以得到列表中任意位置元素的值，那么我们就不必在初始化的时候，把完整list创建出来
    而是在需要的时候，产生结果，这种思想就是延迟操作


生成器(generator)
    Python使用生成器对延迟操作提供了支持。所谓延迟操作
        是指在需要的时候才产生结果而不是立即产生结果。这也是生成器的主要好处

    生成器的提供方法
        生成器函数：常规函数定义，但是，使用yield语句而不是return语句返回结果
            yield语句一次返回一个结果，在每个结果中间
            挂起函数的状态，以便下次重它离开的地方继续执行
        生成器表达式：类似于列表推导
            生成器返回按需产生结果的一个对象，而不是一次构建一个结果列表

生成器语法

"""

#斐波那契数列

#用普通方法
spam = []
def fib(max):
    n,a,b = 0,0,1
    while n < max:
        spam.append(b)
        a,b = b,a + b
        n += 1
    return spam

spam1 = fib(15)
print(spam1)

#用生成器
#yield的作用类似与return，但是它不会退出函数，而是将函数暂时挂起，
#当再次调用这个函数时，会继续执行yield后面的代码

spam2 = []
def fib1(max):
    n,a,b = 0,0,1
    while n < max:
        yield b
        spam2.append(b)
        a,b = b,a + b
        n += 1
    return spam2

spam3 = fib1(15)
print(spam3)
